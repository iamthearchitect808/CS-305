# CS-305

In this scenario, Artemis Financial was a hypothetical client of ours, which was involved in financial consultation for investing, retirement, insurance and savings.  They needed a web-based application which inluded a server-side file verification function to ensure that data received was unchanged in the process of being transferred between the client and server.  In addition, the communications had to be secured to prevent malicious activities.  

The central aspect of the solution was the use of Transport Layer Security, with its various uses of encryption to enhance the security of communications.  Of the available options within TLS 1.3, I chose the most secure algorithm cipher for symmetric encryption (AES-128 GCM), calculating a checksum value (SHA-256), generating asymmetric session keys (elliptic curve 25519), and signing certificate data (2048-bit RSA).  

The use of secure coding practices is important for an effort to deliver a product which carries less risk of sensitive information being accessed by unauthorized users, to save time and expense in patching or retro-fitting security onto existing code, to preserve the reputation of the software company and the client, and to protect against use of the software in ways other than intended.  Especially in for Artemis Financial, these secure coding practices serve to maintain their good standing with the SEC, without which they are unable to conduct business in the US.  

The portion of the vulnerability assessment that I found to be the most helpful in my learning was the benefit of remaining within the Java standard libraries for generating the server certificate and checksum value.  When possible, avoiding the use of third-party libraries can prevent the introduction of new attack vectors into an application.  

My approach to the various layers of security was guided according to the consideration of various perspectives of the application's architecture, including input validation, encapsulation, APIs, code quality, cryptography, and client/server interactions.  Each of these facets necessitated a different approach to increasing security in light of known attacks.  In the future, a combination of this type of analysis with static and functional testing and following Java's secure coding guidelines will prove effective in securing other projects.  

To be sure that the code was functional, I tested the server by running the application, navigating to the local host address in a browser, and verifying that the data and checksum was displayed using secure http.  The use of TLS 1.3 and its corresponding encryption suite, the algorithms in which are, as yet, still uncracked, the use of encapsulation as an object-oriented programming principle, and restricting the use of third-party libraries contributed to the security of the application.  New vulnerabilities were not introduced after code refactoring, confirmed with the use of the Maven dependency check.  

The most beneficial resources I used in this project were the Java Secure Coding Practices website, the National Vulnerability Database, and Iron-Clad Java, a book by Jim Manico and August Detlefsen about building secure web applications using Java.  The first two resources will be especially useful in my career as they are regularly updated.

This project was instrumental in expanding my understanding of TLS, which is in particularly high demand because of the increasing prevalence of web-based applications.  Future employers will be interested to see this report as evidence of my knowledge and use of TLS to secure client-server communications.  
